# Практична робота №1

## Огляд
Мета цієї роботи — ознайомитися з процесом налаштування середовища розробки в Ubuntu Linux та опанувати базові навички програмування мовою C, зокрема роботу з математичними бібліотеками та системними викликами.

## Завдання №1: Обчислення інтеграла нормального розподілу
Програма розраховує ймовірність того, що випадкова величина потрапить у заданий довірчий інтервал [-Z; Z], використовуючи функцію помилок `erf`.

1.Правильно скомпілювати програму з використанням бібліотеки math.h.

2.Додати обробку помилок, щоб перевірити правильність виклику erf.

3.Розширити програму, щоб вона обчислювала довірчі інтервали не тільки для 95%, але й double ci90 = 1.64485;
  
4.Додати можливість введення значень від користувача для довірчого інтервалу.

## Компіляція та запуск

### 1. Компіляція
Використовуйте прапорець `-lm` для підключення математичної бібліотеки та `-Wall` для відображення всіх попереджень:
```bash
gcc -Wall Ex1.c -o Ex1 -lm
```

### Запуск програми
```bash
./Ex1
```
### Результат виконання програми

Вводимо значення 1.96
```
Enter Z-score: 1.96
The integral of a Normal (0,1) distribution between -Z and Z i’s: 0.950004
```
Введемо нечислове значення для змінної Z-score
```
Enter Z-score: e
Invalid input!
```
Отримуємо повідомлення про некоректність вводу.
  
### Результати для 90,95 та 99 відсотків
Додаємо 3 зміні double :

ci90 = 1.64485;\
ci95 = 1.95996;\
ci99 = 2.57583;

В результаті виконання програми отримаємо: 
```
Confidence intervals (integral from -Z to Z):
90% CI: 0.899999
95% CI: 0.95
99% CI: 0.99
```
Також додаємо можливість користувачу обрати значення для довірчого інтегралу(серед 90%,95%,99)
```
Enter Z-score: 2
The integral of a Normal (0,1) distribution between -Z and Z i’s: 0.9545

Choose confidence integral:
1 - 90% Confidence Interval
2 - 95% Confidence Interval
3 - 99% Confidence Interval
Your choice: 1
90% CI: 0.899999
```
### Додамо розрахунок для розподілу Стьюдента
В результаті отримаємо
``` 
Enter Z-score: 1.96
Enter degrees of freedom (df): 20
The integral of a Normal (0,1) distribution between -Z and Z i’s: 0.950004
The integral of a Student distribution: 0.947071 (df=20)
```

## Структура проекту
Проєкт реалізовано у вигляді модульної структури для забезпечення чистоти коду та розділення логіки:
* `Ex1.c` — головний файл програми (інтерфейс користувача, введення даних та меню стандартних інтервалів).
* `erf_module.c` — реалізація математичних функцій (логіка обчислень).
* `erf_module.h` — заголовочний файл із прототипами функцій та макросами стандартних Z-значень (`#define`).
## Інструкція з компіляції та запуску
Оскільки проєкт розбитий на модулі, для збірки необхідно скомпілювати всі файли `.c` разом та підключити математичну бібліотеку:

```bash
gcc Ex1.c erf_module.c -o Ex1 -lm
```
#### Запуск 
``` bash
./Ex1
```
## Компіляція з оптимізацією

Для підвищення продуктивності математичних обчислень програму можна скомпілювати з різними рівнями оптимізації компілятора `gcc`:

### Рівень O2 (стандартна оптимізація):
Оптимізує швидкість виконання без значного збільшення розміру файлу.
```bash
gcc -O2 Ex1.c erf_module.c -o Ex1_O2 -lm
```

### Рівень O3 (максимальна оптимізація):
Найвищий рівень оптимізації, який фокусується виключно на швидкості роботи програми. Компілятор намагається максимально розпаралелити обчислення та вбудувати функції безпосередньо в місця їх виклику (inlining).
```bash
gcc -O3 Ex1.c erf_module.c -o Ex1_O3 -lm
```

# Завдання №2:Дослідити бібліотеки доступні у системі
1)Використовуйте команду ldd, щоб перевірити, які бібліотеки використовуються вашими програмами (наприклад, ls або gcc).\
2)Знайдіть бібліотеку з math-функціями, визначте її точне місце розташування (find /usr/lib -name "*math*").\
3)Перевірте символи бібліотеки за допомогою nm або objdump. Наприклад:
 nm -D /usr/lib/libm.so | grep erf\
4)Проаналізуйте залежності бібліотек за допомогою ldd або objdump -p.\
5)Напишіть скрипт на Bash, який аналізує всі бібліотеки у /usr/lib, витягує з них символи та шукає певні функції (наприклад, sin, cos, exp).

### Перевіримо бібліотеки за допомогою команди ldd
```bash
ldd Ex1
```
### В підсумку побачимо список динамічних бібліотек від яких залежить працездатність програми.
```bash
    linux-vdso.so.1 (0x00007ffca8929000)
    libm.so.6 => /lib/x86_64-linux-gnu/libm.so.6 (0x00007b6d88239000)
    libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007b6d88000000)
    /lib64/ld-linux-x86-64.so.2 (0x00007b6d88331000)

```
### Шукаємо бібліотеку  з math-функціями.
```bash
    find /usr/lib -name "*math*"
```
### В результаті отримаємо даний перелік.
```bash
    /usr/lib/x86_64-linux-gnu/libquadmath.so.0
    /usr/lib/x86_64-linux-gnu/libquadmath.so.0.0.0
    /usr/lib/gcc/x86_64-linux-gnu/13/libquadmath.so
    /usr/lib/gcc/x86_64-linux-gnu/13/include/quadmath.h
    /usr/lib/gcc/x86_64-linux-gnu/13/include/quadmath_weak.h
    /usr/lib/gcc/x86_64-linux-gnu/13/crtfastmath.o
    /usr/lib/gcc/x86_64-linux-gnu/13/libquadmath.a
```
Можемо зробити висновок,що більша частина math-функцій знаходяться в бібліотеці libm.so.

### Перевіряємо символи бібліотеки 
```bash
nm -D /usr/lib/x86_64-linux-gnu/libm.so.6 | grep erf
```
#### В результаті отримаємо
```bash   
000000000002df70 W erf@@GLIBC_2.2.5
000000000002e520 W erfc@@GLIBC_2.2.5
0000000000041200 W erfcf@@GLIBC_2.2.5
000000000005dbd0 W erfcf128@@GLIBC_2.26
0000000000041200 W erfcf32@@GLIBC_2.27
000000000002e520 W erfcf32x@@GLIBC_2.27
000000000002e520 W erfcf64@@GLIBC_2.27
000000000001bec0 W erfcf64x@@GLIBC_2.27
000000000001bec0 W erfcl@@GLIBC_2.2.5
0000000000040cf0 W erff@@GLIBC_2.2.5
000000000005fc90 W erff128@@GLIBC_2.26
0000000000040cf0 W erff32@@GLIBC_2.27
000000000002df70 W erff32x@@GLIBC_2.27
000000000002df70 W erff64@@GLIBC_2.27
000000000001ba60 W erff64x@@GLIBC_2.27
000000000001ba60 W erfl@@GLIBC_2.2.5
```
### Перевіряємо залежності бібліотек 
```bash
ldd /lib/x86_64-linux-gnu/libm.so.6
```
#### В результаті отримаємо
```bash
linux-vdso.so.1 (0x00007fffa82b7000)
libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007fc337c00000)
/lib64/ld-linux-x86-64.so.2 (0x00007fc337fee000)
```
Робимо висновок,що математична бібліотека сама залежить від:
* `libc.so.6` — стандартна бібліотека С (забезпечує базові системні виклики).
* `ld-linux-x86-64.so.2` — динамічний завантажувач.

###Написання Bash-скрипта для автоматизації пошуку функцій
Для автоматизації аналізу бібліотек було створено скрипт Ex2.sh. Він дозволяє швидко знайти адреси функцій (наприклад, sin, cos, exp) у системних файлах.

Код Bash
```
#!/bin/bash

# Шлях до знайденої математичної бібліотеки
LIB_PATH="/lib/x86_64-linux-gnu/libm.so.6"

echo "--- Аналіз бібліотеки $LIB_PATH ---"

# Список функцій для пошуку
FUNCTIONS=("sin" "cos" "exp")

for FUNC in "${FUNCTIONS[@]}"; do
    echo "Пошук функції: $FUNC..."
    # nm витягує символи, grep шукає точний збіг назви функції
    nm -D "$LIB_PATH" | grep -w "$FUNC"
done

echo "--- Пошук завершено ---"
```
#### Налаштування прав доступу

У Linux після створення файлу йому потрібно надати права на виконання, інакше система видасть помилку "Permission denied". Це робиться за допомогою команди:

```
chmod +x Ex2.sh
```
Результат виконання скрипта:
Запуск здійснюється командою ./Ex2.sh. Отриманий результат:
```
Пошук функції: sin...
0000000000030ae0 i sin@@GLIBC_2.2.5
Пошук функції: cos...
0000000000030b30 i cos@@GLIBC_2.2.5
Пошук функції: exp...
0000000000013b10 T exp@GLIBC_2.2.5
000000000003a700 T exp@@GLIBC_2.29
--- Пошук завершено ---
```
Висновок:
Скрипт успішно ідентифікував точки входу для функцій у бібліотеці. Наявність прапорців i та T підтверджує, що ці символи є "текстовими" (тобто містять виконуваний код) і доступні для лінкування з іншими програмами.
